
[{"content":"要说pwn中最基础的一种攻击手段，必须是栈溢出，但是什么是栈，为什么要溢出？在正式了解栈溢出之前，需要简单了解一些前置知识：\nELF文件结构 # 我们要了解一个程序是如何从磁盘到内存，然后跑起来的，但是要了解这个问题，我们也要先简单了解一下ELF。\nELF（Executable and Linkable Format）是Linux中的一种二进制文件格式，根据文件的不同功能，ELF可被分类为可执行文件、目标文件、共享库。什么是目标文件和共享库？这里就不细讲了，以后迟早会说到（挖坑ing）\n我们重点要讨论的是可执行文件的结构，需要注意的是ELF文件有两种视图 \u0026mdash; 链接视图和执行视图，区分这两种视图的目的是为了让链接器和装载器都能快速的了解程序布局，提高链接和执行这两个不同的操作的效率。在不同的视图下结构会有一些微妙的差别，我们来简单看一下：\n文件头 \u0026mdash; 两个视图共有 # 文件头是ELF文件的标签，用来描述这个文件的一些信息，具体包括：\n魔数：用来说明这是一个ELF文件\n文件类型：是哪种功能的ELF文件\n架构：这个文件在什么样的架构下运行\n入口地址：这个文件从哪里开始运行\n程序头表和节头表的地址：字面意思\n节头表与节 \u0026mdash; 链接视图 # 在链接视图中，我们主要看节，这个结构是给链接器用的，它需要将来自不同文件的具有相同功能的代码或数据整合到一起，在这里功能最重要！\n节头表会列出每个节的名称、功能、大小、以及在文件中的位置。\n节是储存数据和代码的最小逻辑单位，当我们链接多个目标文件的时候，都是以节为对象进行操作的。\n不同的节有不同的功能，常见的节与其功能如下：\n.text：存储代码。\n.data：存储已经初始化的全局变量或静态变量。\n.bss：存储未初始化的全局变量和静态变量，注意这个节在文件中只占用了描述该节具体信息的空间，不存储实际数据，是用来在内存中占用指定大小空间的。\n.rodata：存储只读数据。\n.symlab：存储函数，全局变量等的名字和地址，这里的名字指的是名字的字符串存储的地址。\n.shstrtab：存储节的名字，同上。\n.strtab：存储前两个节中的名字的字符串。\n.dynamic：存储动态链接需要的信息，其中用到的字符串和前面类似，只存储地址。\n.dynsym .dynstr：存储前面这个节的字符串。\n程序头表与段 \u0026mdash; 执行视图 # 在执行视图中，我们主要看段，这个结构是给加载器看的，他需要将具有不同权限的代码或数据区域分开，方便管理，在这里权限最重要！\n程序头表会列出每个段的类型、权限、大小以及如何被装载到内存中。\n段是装载程序内容的最小逻辑单位，将程序装载到内存中的时候，以段为对象进行操作。\n一个段包含了多个节，这些节有着相同的权限，常见的段如下：\n代码段（LOAD段）：可读可执行 包含了.text、.rodata、.plt等节\n数据段（也叫LOAD段）：可读可写 包含了.data、.bss、.got等节 （什么是plt和got？以后会说到（继续挖坑ing））\n动态链接路径段（PT_INTERP段）：可读 包含了.interp节，存储了动态链接器的路径\n动态链接段（PT_DYNAMIC段）：可读可写 包含了.dynamic节，存储了动态链接需要的数据\n内存装载 # 当我们运行一个程序时，会先进行一些准备工作，也就是内存装载，将程序映射到内存空间中变为进程，装载过程分三步：\n读取文件头、划分虚拟内存空间 # 首先，系统需要读取文件头，了解一些相关信息，比如是否为合法ELF文件，入口地址在哪之类的信息。\n接下来硬件会给程序分配一个虚拟内存空间，在32位中，每个程序都是最大空间，也就是4G，但是在64位中，最大空间太大了，不太好管理，所以分配的空间大小比较灵活。\n你可能有疑问：一台计算机的内存好像没有那么大，怎么做到给每个程序都分配那么大内存空间的？我们要知道这个内存空间只是一个虚拟的概念，是一种逻辑上的固定大小的连续的空间，实际上这个空间对应的物理内存空间既不连续，也不会那么大，具体受硬件限制，而且装载的所有内容也不是都始终在物理内存中（这个叫交换技术，大概原理是只有活跃的部分才会在内存中，不活跃的都扔进磁盘中的交换空间），甚至划分完虚拟内存后还不会全部立刻关联到物理内存区域，一般在物理内存找到空间写入数据之后才会关联到虚拟内存。也就是说虚拟内存空间的一些规格和物理内存关系不大。像不像给你画大饼的hxd？把这篇文章转发给ta，让ta好好学习一下什么叫内存装载！\n不过这么大的虚拟内存空间也不是只给程序用的，我们把给程序用的空间叫做用户空间，除此之外还有内核空间，内核空间一般在虚拟内存空间的最高处。\n我们知道硬件资源是有限的，为了更好的使用硬件资源，操作系统规定了一个唯一的访问硬件资源的方法：通过内核访问，当程序需要执行文件读写等涉及硬件的操作时，就要通过系统调用，让内核帮你访问硬件资源。\n到了这步，分配的虚拟内存空间是这样的：\n装载 # 接下来正式把程序按照段复制到物理内存中，分别设置不同权限，接下来关联到虚拟内存。\n在现在，这里的复制也不是一次性将整段完全复制与关联，有些段会分成多部份，只有在使用时才会搞到物理内存中设立关联。\n虚拟内存空间和文件都是线性的，我们可以把他们想象成一条长的线段，按单位长度分成许多份，每一份为一字节，这个装载过程就是从虚拟内存空间这条线段的某一点开始，参照文件中的结构，一直向下与物理内存中存储的有关进程的信息相对应，最终这篇空间对应的段与段之间的相对结构应该是与实际文件结构相同的。\n在虚拟内存空间选择的这个起始点叫基址，一般来讲是不变的，但是现在在PIE（地址无关化可执行）保护（这个保护需要同时开启ASLR才管用，下面会说到）的作用下，保持文件内部的相对结构不变，基址可以是“随机”的，不过这个随机也不是完全在用户空间中为所欲为：在虚拟内存空间的最低处，划分了一个保留区域，主要目的是保护一些非法访问，比如空指针访问；而在其他地址处，还要预先留下足够的空间，之后要放置堆栈等东西。\n也就是说，我们除了将程序装载到物理内存，与虚拟内存空间关联以外，还要划分一个保留区，为后续初始化划分一些区域，这些都完成之后，虚拟内存空间大概是这样的：\n这里要注意不同预留区域之间可能会有一些空白区域，现在很多系统都开启了ASLR（地址空间随机化）保护，这个保护会在规定的合法区域内随机选择一个基址，并从这个地址开始向下划分一片预留区域，专门用来给将要初始化的其中一个部分用，比如堆，栈等，不同的部分会划分不同的区域，这就会导致不同区域之间空出一些空白区域。当关闭这个保护时，基址固定，空白区域会少很多。\n初始化、动态链接 # 这时到了准备的最后一步，首先为栈分配物理内存，将其映射到虚拟内存空间中，栈空间内部会经历一个初始化过程，准备完成后会设置寄存器，调整一些初始参数。\n然后会映射动态链接器，接下来就开始了最重要的一步：动态链接。\n早期的程序导入一些外部内容都是静态链接，特点是在编译时就会把外部的内容导入到程序中，好处是只需要一个可执行文件就能跑，但是也有坏处：假设有一千个程序都要用同一个内容，都静态链接的话，磁盘中不仅会存入一千个程序，还会有一千个相同的内容！所以就出现了动态链接：在编译时只需要记载需要链接什么内容，在运行时将程序和这些内容一起搞到内存中，映射到同一个虚拟内存空间，这就是动态链接。动态链接的内容会被映射到虚拟内存空间中的堆与栈之间的一个区域，这里管他叫库预留区。\n接下来就剩堆区，堆区会怎么样呢？堆区比较特殊：这个区域动态分配内存。一开始划分预留区的时候，堆区的大小就是0，直到程序申请内存并实际访问时，堆区才会开始映射数据。如果没有申请内存的操作，堆区大小可以始终为0。\n至此，整个内存装载就结束了！此时的内存空间是这样的，程序可以开始运行了。\n栈与寄存器 # 在初始化的过程中我们提到了三个东西：栈、堆、寄存器，这三个负责存储一些程序计算时的中间状态，其中堆比较特殊，可以暂时不讲，现在来看看栈与寄存器到底是什么：\n栈 # 栈是在虚拟内存空间中一片连续的区域，由栈底和栈顶划分范围，其中栈底在高地址，栈顶在低地址。栈中存储了函数调用时的一些局部信息，每一个正在调用的函数都有一个独立的用于存储信息的部分，叫做栈帧。\n栈的特点是在存储和取出时只能操作栈顶的数据，是一种典型的后进先出结构，由于新存入的数据在栈顶，也就是低地址处，所以说栈向低处生长。\n寄存器 # 寄存器是一种独立于内存，在CPU上的存储单元，与内存相比速度极快，但是容量极小，数量极少，适合做一些临时的存储。\n在32位处理器中，寄存器都以E开头，比如EAX，大小是32bits（4字节），而在64位处理器中，以R开头，比如RAX，大小是64bit（8字节）。\n我们举一些常用的32位寄存器：\n通用寄存器 具有通用的存储数据的功能，但是有的有一些专用功能。\nESP：存放指向栈顶的指针，也就是存放栈顶地址。\nEBP：存放指向栈底的指针，也就是存放栈底地址。当指定栈上某一处的一个数据时，通常用EBP加上其相对于栈底的位置来表达这个数据的位置。\nEAX：执行加减乘除计算，存储累加值，存放函数返回值，存放系统调用号。\nEBX：存储内存地址的基址。\nECX：作为循环计数器。\nEDX：存放I/O端口号**。\nESI：当对字符串或数组操作时，这个寄存器可以存放来源的地址。\nEDI：当对字符串或数组操作时，这个寄存器可以存放目的地址。\n这些寄存器在64位中都能找到对应的R开头的寄存器，在64位中也可以访问E开头的寄存器去只操作这些寄存器的低32位，清空高32位。\n除此之外，64位还加了R8到R15共8个额外的通用寄存器。\n指令寄存器 EIP：存放一个指针，始终指向下一条指令，也就是存储了下一条指令的地址，这个寄存器不能被直接修改，只能在执行完当前指令后自动更新，或者被一些相关的指令间接修改，比如CALL、RET、JMP。 64位中对应RIP，也可以访问EIP，操作RIP低32位，清空高32位。\n除此之外还有标志寄存器与段寄存器，一般做题用不到，这里就不讲了。\n总结 # 本篇文章讲述了一些pwn中的基础知识，包括ELF文件结构，内存装载，栈与寄存器，有些知识可能讲了不会立刻用到，所以不需要全都记住，用到了再现查也没问题。\n所以我们讲了什么是栈，但是为什么要栈溢出？他会给我们什么好处？这里涉及到栈帧的基本结构，在下一篇文章中会说到。\n","date":"2025-12-12","externalUrl":null,"permalink":"/posts/pwn/elf-load-stack-register/","section":"文章合集","summary":"从磁盘到内存，程序经历了什么？","title":"ELF、内存装载、栈与寄存器","type":"posts"},{"content":"","date":"2025-12-12","externalUrl":null,"permalink":"/","section":"KA's Blog","summary":"","title":"KA's Blog","type":"page"},{"content":"二进制安全合集！\n","date":"2025-12-12","externalUrl":null,"permalink":"/categories/pwn/","section":"文章分类","summary":"\u003cp\u003e\u003cstrong\u003e二进制安全合集！\u003c/strong\u003e\u003c/p\u003e","title":"PWN","type":"categories"},{"content":"要选哪一个呢？\n","date":"2025-12-12","externalUrl":null,"permalink":"/categories/","section":"文章分类","summary":"\u003cp\u003e\u003cstrong\u003e要选哪一个呢？\u003c/strong\u003e\u003c/p\u003e","title":"文章分类","type":"categories"},{"content":"来看看我都写了啥！\n","date":"2025-12-12","externalUrl":null,"permalink":"/posts/","section":"文章合集","summary":"\u003cp\u003e\u003cstrong\u003e来看看我都写了啥！\u003c/strong\u003e\u003c/p\u003e","title":"文章合集","type":"posts"},{"content":"大概一个半月之前，我打算开始学pwn，那时我还是啥都不知道的小菜。花了半天时间配了个WSL，找了一堆视频和文章，有的上来开始讲ELF，有的上来开始讲栈溢出，虽然这些在pwn中确实很基础，但我看了半天感觉确实也很离谱。\n全 都 看 不 懂 ！\n后来找了个大佬求带，大佬当时只给我讲了一个题，那道题不需要各种漏洞，只需要做一个“简单的口算”，在限定时间内求出两个几千左右的随机数的积，我顿感震惊：这就是最基础的二进制安全吗？防止开挂破坏玩家生态？？\n所以说，作为学了一个月还是没有啥成就的小菜，要来写（shui）第一篇blog，还必须要有干货，写什么？那就写python pwntools怎么用，如何写一个神奇的口算脚本！\n基础使用方法 # 首先导入pwntools：\nfrom pwn import * 我们的主要目的是连接程序进行交互，但是建立连接之前，咱们也可以进行一些设置。\n设置context # 这里可以设置一些背景信息。你可以告诉脚本使用的架构，操作系统，日志详细程度等详细信息，一般情况下是可以不设置的，但是设置了可能方便某些模块的使用，或者获得更详细的调试信息。\n# 可以这样 context(xx = \u0026#34;xx\u0026#34;, yy = \u0026#34;yy\u0026#34;) # 也可以这样 context.xx = \u0026#34;xx\u0026#34; context.yy = \u0026#34;yy\u0026#34; # 具体设置的参数： context.arch = \u0026#34;amd64\u0026#34; # 架构，有i386，amd64等 context.os = \u0026#34;linux\u0026#34; # 操作系统，一般都是linux context.log_level = \u0026#34;debug\u0026#34; # 日志详细程度，选择debug之后每次接收或者发送都有详细的日志 设置目标libc，ELF # 你可以设置ELF和libc，这样可以让脚本帮你找一些gadgets的位置，比如标准库函数的偏移地址。\nxx = ELF(\u0026#34;./xx\u0026#34;) #指定一个ELF # 接下来你就可以对这个ELF做一些操作，比如： system_offset = xx.symbols[\u0026#39;system\u0026#39;] # 找一些函数的地址，如果开了地址随机化就是偏移地址 binsh_offset = xx.search(b\u0026#34;/bin/sh\u0026#34;) # 搜一些字符串的地址，开了随机化同上 puts_got = xx.got[\u0026#39;puts\u0026#39;] # 找一个函数的got表地址，同上 puts_plt = xx.plt[\u0026#39;puts\u0026#39;] # 找一个函数的plt表地址，同上 xx.address = 0x114514 # 设置这个ELF的基址，之后搜索到的地址都是加上基址之后的实际地址 启动程序 # 接下来就可以启动程序，开始操作了。\nxx = process(\u0026#34;./xx\u0026#34;) # 开一个本地程序 xx = connect(\u0026#34;0.0.0.0\u0026#34;, 11111) # 连接一个在线环境 gdb.attach(xx) # gdb附加调试 gdb.attach(xx, \u0026#39;\u0026#39;\u0026#39; b 0x114514 continue \u0026#39;\u0026#39;\u0026#39;) # 还能顺带给gdb发点指令！ 基础交互 # 你可以对程序做一些交互，比如发送和接收。\n# 接收 xx.recv(n) # 收n个字节 xx.recvline() # 收一行 xx.recvuntil(b\u0026#39;xx\u0026#39;) # 收到xx为止 xx.recvall() # 一直收 a = xx.recv(114514) # 还能把收到的字符串赋给a！ a = xx.recv(16).strip() # 移除两端的空白字符 a = int(xx.recv(16), 10) # 如果收到的字符串像个数字，可以把他按特定进制转换成整数 xx.clean() # 还能把收到的扔了！ # 发送 xx.send(b\u0026#39;xx\u0026#39;) # 发送xx，不带回车 xx.sendline(b\u0026#39;xx\u0026#39;) # 带回车 xx.sendafter(b\u0026#39;xx\u0026#39;, b\u0026#39;yy\u0026#39;) # 收到xx后发yy，不带回车 xx.sendlineafter(b\u0026#39;xx\u0026#39;, b\u0026#39;yy\u0026#39;) # 收到xx后发yy，带回车 payload = b\u0026#39;xx\u0026#39; + b\u0026#39;yy\u0026#39; xx.send(payload) # 构造好了再发 payload = cyclic(100) xx.send(payload) # 发垃圾 payload = p32(0x64636261, endian = \u0026#39;little\u0026#39;) # 以指定字节序（不指定默认小端序）将整数打包为特定位数的字节串，不足高位补0 # payload = b\u0026#39;abcd\u0026#39; payload = u32(b\u0026#39;abcd\u0026#39;, endian = \u0026#39;little\u0026#39;) # 以指定字节序（不指定同上）将字节串解包为特定位数的整数，长度必须为32bits # payload = 0x64636261 a = 114514 xx.send(str(a).encode()) # 将数字转化为字符串编码输出，注意要用encode编码，不编码默认用ascii编码，可能发送的不是你想发送的东西 # 其他 a = 2 log.info(\u0026#34;xx\u0026#34;) # 可以添加一些醒目的调试信息 log.success(\u0026#34;a = \u0026#34; + str(a)) # 成功信息，注意后面加的只能是字符串 # 还有警告warn，错误error，等待waitfor等信息 xx.interactive() # 由你亲自上阵进行交互！一般用来验证是否成功getshell，或者拿flag 实战演练 # 现在我们就来尝试做一个口算脚本！\n例题：极客大挑战2024 - 简单的签到\n拿到文件，拖入ida，主要的函数如下：\nint math1() { unsigned int v0; // eax int v2; // [rsp+10h] [rbp-10h] int v3; // [rsp+14h] [rbp-Ch] v0 = time(0LL); srand(v0); v3 = rand() % 10000 + 1; v2 = rand() % 10000 + 1; printf(\u0026#34;%d * %d = \u0026#34;, v3, v2); if ( (unsigned int)get_input_with_timeout() != v2 * v3 ) { printf(\u0026#34;Incorrect. The correct answer was %d. Exiting...\\n\u0026#34;, v2 * v3); exit(1); } puts(\u0026#34;Correct! Opening shell...\u0026#34;); return system(\u0026#34;/bin/sh\u0026#34;); } 这个函数会随机两个一万以内的数，要求你在限定时间内输入这两个数的积。\n我们只要收到数字然后相乘就可以了，但是他发送的是一个乘法，不是单纯的两个数字，如何去掉其他字符呢？\n这时就可以用上面提到的recvuntil和strip了！\n写好的payload如下：\nfrom pwn import * # 我们也可以设置context的，但是这里不需要设置，懒了（跪 io = process(\u0026#34;./main\u0026#34;) io.recvuntil(b\u0026#39;challenge.\u0026#39;) # 接收欢迎信息 io.send(b\u0026#39;\\n\u0026#39;) # 按任意键继续 a = int(io.recvuntil(b\u0026#39; \u0026#39;).strip()) # 收到乘号前面的空格为止，去除空白 log.success(\u0026#34;a = \u0026#34; + str(a)) # 实际上可以不加 io.recvuntil(b\u0026#39;* \u0026#39;) # 把乘号和后面的空格收了 b = int(io.recvuntil(b\u0026#39; \u0026#39;).strip()) # 收到等号前面的空格为止，去除空白 log.success(\u0026#34;b = \u0026#34; + str(b)) r = a * b # 计算 log.success(\u0026#34;a * b = \u0026#34; + str(r)) io.recvuntil(b\u0026#39;= \u0026#39;) # 把等号和后面的空格收了 io.sendline(str(r).encode()) # 编码输出 io.interactive() # 开启交互模式 先给拿到的附件里的ELF程序加上可执行权限，让脚本能打开程序，运行脚本。\nchmod +x main python3 1.py 等进入交互模式后，你就可以验证自己有没有成功getshell了。\n# 本地可以用这个 whoami # 发送用户名 # 远程可以用这个 ls # 看看当前目录中的东西 cat flag # 如果有flag，直接读取 最后大概就是这样：\n[+] Starting local process \u0026#39;./main\u0026#39;: pid 8358 [+] a = 9307 [+] b = 1667 [+] a * b = 15514769 [*] Switching to interactive mode Correct! Opening shell... $ whoami kioroshiaki 总结 # 本篇文章讲述了一些python pwntools中的常见指令与语法。\n看完最后的脚本，你会发现前面好多内容完全看不懂 / 用不到，不过这是为了水blog啊（被打\n确实有很多内容暂时不会用到，但是这里就先把他们归类到一起，不用全部记住，以后用到了可以再查\n第一篇blog就是这样，终于水完了（逃\n","date":"2025-12-06","externalUrl":null,"permalink":"/posts/pwn/pwntools/","section":"文章合集","summary":"看完这篇就能成为口算大神了吗？","title":"Python Pwntools的基础使用方法","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":"https://converter258.cn/","permalink":"/friends/convr3/","section":"友链合集","summary":"CUIT好哥们","title":"Converter258","type":"friends"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"KioroshiAki，简称KA。\n感兴趣 / 正在学习 # 程序设计\n网络空间安全 / 信息安全\nCTF中PWN和RE相关知识\n电子音乐作编混母\nblog更新方向 # 一些CTF的基础知识 / 教程\n一些程序设计的知识（未来考虑）\n以及一些别的\n自我介绍完。\n","externalUrl":null,"permalink":"/about/","section":"KA's Blog","summary":"\u003cp\u003e\u003cstrong\u003eKioroshiAki\u003c/strong\u003e，简称\u003cstrong\u003eKA\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003e\u003cstrong\u003e感兴趣 / 正在学习\u003c/strong\u003e\n    \u003cdiv id=\"感兴趣--正在学习\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#%e6%84%9f%e5%85%b4%e8%b6%a3--%e6%ad%a3%e5%9c%a8%e5%ad%a6%e4%b9%a0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e程序设计\u003c/p\u003e","title":"我    是    谁    ？","type":"page"},{"content":"来看看hxd们写了啥！\n","externalUrl":null,"permalink":"/friends/","section":"友链合集","summary":"\u003cp\u003e\u003cstrong\u003e来看看hxd们写了啥！\u003c/strong\u003e\u003c/p\u003e","title":"友链合集","type":"friends"}]